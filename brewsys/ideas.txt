mash system:

1. when file is loaded:
 - time is set for the first step time
 - hit start button to fire the burners and start heating
 - send an alert when strike temp is reached and shut off burner
2. after mash in:
 - hit start to start timer and initialize temp control cycle
 - ability to pause and abort automatic control
3: when step is done:
 - start reset timer to next step time
 - fire burners and heat to next step temp
4: when next step temp is reached:
 - start timer automatically
 - reenter temp control cycle
5: repeat 3 and 4 as necessary through mash out
6: when done:
 - shut everything down
#########################################################

1. app opens to basic timer function, "00:00" with
   start and reset buttons = DONE

2. Timer -> Set to set timer. - DONE

3. File -> "Load" or "Open" to select file from a specific
   directory which contains only beer.xml files - DONE

4. When a file is selected a list of mash steps populates on
   the left and boil additions on the right

5. Timer menu (buttons?) with options to run the mash or boil cycle.

#####################################################################


import lines
- time, wx, os, modules
- timer class module
- other separate modules

global variables
- system parameters (window size, timer delay, window titles, etc)
- globally available objects (timers, xml file, etc)

class - top level called at program start
- may have some class bindings for file selection etc
- otherwise contains only an InitUI method to set up the window.

class - new window for setting the timer
- inherits from wx.Frame used to set the timer manually

class - new window for selecting a file
- inherits from wx.Frame used to load a .XML file for parsing

initialize the app
- create an wx app and run the World class through MainLoop() method

- for close method confirmation dlg -

def OnClose(self, event):
    dlg = wx.MessageDialog(self, 
        "Do you really want to close this application?",
        "Confirm Exit", wx.OK|wx.CANCEL|wx.ICON_QUESTION)
    result = dlg.ShowModal()
    dlg.Destroy()
    if result == wx.ID_OK:
        self.Destroy()
        
def BrewType(self, e):
        """ load a timer based upon the brewing style """
        try:
            self.XML = self.recipe.GetRecipe()
            self.TREE = ET.parse(self.XML)
            self.TIMER.GetXML(self.TREE)
            self.brewType = self.TIMER.GetBrewType()
            self.mashSteps = self.TIMER.GetMashSteps()[:]
            self.steps = len(self.mashsteps)               # the total number of mash steps
            if self.Mashable:
               self.CallMash(None)
            else:
               self.CallBoil(None)

        except:
            # may need to raise parse error dialog if fpath is bad!!!
            self.RecipeErrDlg()

    def CallMash(self, e):
        self.step_count = 0                            # this needs to be in the init
                        
        try:
            if self.steps > 0 and self.step_count < self.steps:
                self.mashFlag = True                   # deprecate
                step = self.mashSteps.pop(0)           # instead of this use:
                
                step = self.mashSteps[self.step_count-1] # this instead
                self.TIMER.Set(step[1], 0)             # with the new timer set method you should be able to set with (step[1])
                self.step_count += 1                   # move to the next step in the list
                self.OnRefresh(None)
            else:
                self.CallBoil(None)
                self.mashFlag = False                  # deprecate
        except:
            # use ParseErrDlg(self) instead of:
            self.RecipeErrDlg()

    def CallBoil(self, e):
        self.mashFlag = False                          # deprecate
        try:
            boil = self.TIMER.GetBoilTime()
            self.TIMER.Set(boil[0], boil[1])           # with the new timer set method you should be able to set with (boil[0])
            # refresh the display
            self.OnRefresh(None)

        except:
            # a messag dialong would nice here !!!
            self.RecipeErrDlg()

    def Mashable(self):
        # should partial mash and biab be included? !!!
        """ Returns True if the brew type is All Grain. """
        return self.brewType == 'All Grain'
        
    # change to ParseErrDlg(self) and use in except for BrewType() method 
    def OnParseErr(self):                          
        """ This will need a pop up dialog!!! """
        return "The file path is incorrect"
        
   ################################################################
   # when double clicking a step in mash_list:
   
   def OnMashListDC(self, e):
       # set self.step_count to the appropriate index from choices list
       sel = <mash list box>.GetSelection() # this should be int index
       self.step_count = sel
       # call callMash() method
       self.CallMash(None)
   
   # add event binding for double click event and this method
   
   # next method to to bind to a "Next" button to skip to the next step
   # same for previous?
   
   new method for populating the hopslist may have to looks somethin like this:
   
   D = {'a':[[1,2,3], [4,5,6]], 'b':[[7,8], [9,10]]}

   for key in D.keys():
      for time in D[key]:
         print key, time[0]
         
   new version of GetMessage():
   
   def GetMessage(self):
        """ Information about one hop from the beer.xml doc. """
        # a tuple of (name(string), amount(int), time(int)) for a hop
        s = self.TIMER.GetAddition()
        hops = ''
        for one in s:
            hops += '{} oz of {}\n'.format(one[1], one[0])
        
        return '{} Minutes! Add: \n{}'.format(one[2], value)
        
        
################################################### more ideas

brewsteps = {'Mash' : [('sach', 150, 60), ('Mash Out', 175, 10)],
             'First Wort' : [('Saaz', 1, 60), ('Hallertau', .5, 60)],
             'Boil' : {60 : [('Cascade', 1, 60 ), ('Chinook', .5, 60 ) ], 0 : [('Simcoe', 2, 0 )]}}

mashsteps = brewsteps['Mash'] #- list 

firstwort = brewsteps['First Wort']#- list

boil = brewsteps['Boil'] #- dict

mashstep = 0
steps = len(mashsteps)

print brewsteps
print
print mashsteps
print
print firstwort
print
print boil

#MashMethod:
while mashstep < (steps+1): # this would be the natural result of calling CallMash() when the timer is 00:00
	if mashstep < steps:
	    #SetTime(mashsteps[step][2])
	    print mashsteps[mashstep][2]
	    mashstep += 1	    

	elif firstwort != []:
	    # <show hop dialog for FWH>
		for hop in firstwort:
			print hop # pop dialog for hop addition
			
	    # <reset step to 0?> I don't think I'll do this, 
	    # may be better to leave it at len(mashsteps) and only reset when you callmash()
		
	    # <change to Boil method>
		print 'Going to Boil'
		break #remove this !!!
	
	else:
		# set the boil timer and go!
		print 'Going to Boil' 
		break #remove this !!!

move StopTimer to CallSteps method, and remove from CallMash, CallBoil, and OnNextStep !!!

    def CallSteps(self):
        self.StopTimer()
        boil_time = self.TIMER.GetBoilTime() # make a self method and move to LoadSteps()!!!

        if self.step_count < self.steps:
            step = self.mash_steps[self.step_count]
            self.TIMER.Set(self.mash_steps[self.step_count][1])
            self.UpdateTimer()
            self.step_count += 1

            # helper function !!!
            label = step[0]
            label2 = str(step[1]) + ' Minutes'
            self.ChangeLabels(label, label2)
            
            #self.step_text.SetLabel(label)
            #self.step_text2.SetLabel(label2)
            #self.grid.Layout()

        elif self.first_wort != [] and self.step_count != 99:
            self.HopDlg(self.first_wort)
            self.TIMER.Set(boil_time)
            self.UpdateTimer()
            self.step_count = 99

            # helper function !!!
            label = 'Boil'
            label2 = str(boil_time) + ' Minutes'
            self.ChangeLabels(label, label2)
            
            #self.step_text.SetLabel(label)
            #self.step_text2.SetLabel(label2)
            #self.grid.Layout()

        elif self.step_count != 99:
            self.TIMER.Set(boil_time)
            self.UpdateTimer()
            self.step_count = 99

            # helper function !!!
            label = 'Boil'
            label2 = str(boil_time) + ' Minutes'
            self.ChangeLabels(label, label2)
            
            # self.step_text.SetLabel(label)
            # self.step_text2.SetLabel(label2)
            # self.grid.Layout()
            
    def ChangeLabels(self, label, label2):
    	
    	self.step_text.SetLabel(label)
        self.step_text2.SetLabel(label2)
        self.grid.Layout()
